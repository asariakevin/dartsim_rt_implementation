model DartSim {
	class RandomSeed {
		protected attribute instance: `std::unique_ptr<RandomSeed>`[1]
		protected attribute uniform: `std::uniform_int_distribution<>`[1]
		protected attribute randomGenerator: `std::default_random_engine`[1]


		public operation RandomSeed():  `` `
			randomGenerator(std::random_device()())
		`

		public operation getInstance():  `RandomSeed&` `
			if (instance.get() == nullptr) {
				instance.reset(new RandomSeed);
			}
			return *instance;
		`

		public static operation getNextSeed():  `int` `
			return getInstance().getSeed();
		`

		public operation seed(seed: int[1]):  `void` `
			getInstance().randomGenerator.seed(seed);
		`

		public operation getSeed():  `int` `
			return uniform(randomGenerator);
		`

	}
		class Threat {
			protected attribute  range: double[1]
			protected attribute  destructionFormationFactor: double[1]
			protected attribute  uniform: `std::uniform_real_distribution<>`[1]
			protected attribute  randomGenerator: `std::default_random_engine`[1]

			public operation Threat(range: `double`[1], destructionFormationFactor: `double`[1]): `` `
			  range(range);
			  destructionFormationFactor(destructionFormationFactor);
			  randomGenerator(RandomSeed::getNextSeed());

			`

			public operation isDestroyed(threatEnv: `RealEnvironment`[1],config: `TeamConfiguration`[1], location: `Coordinate`[1]): `bool` `
					bool destroyed = false;
					bool threat = threatEnv.isObjectAt(location);
					if (threat) {
						double probOfDestruction = getProbabilityOfDestruction(config);

						double random = uniform(randomGenerator);
						destroyed = (random <= probOfDestruction);
					}
					return destroyed;
			`

			public operation getProbabilityOfDestruction(config: TeamConfiguration): `double` `
					double probOfDestruction =
							((config.formation == TeamConfiguration::Formation::LOOSE) ? 1.0 : (1.0 / destructionFormationFactor))
							* max(0.0, range - config.altitudeLevel) / range;

					// ECM reduces the prob of destruction
					if (config.ecm) {
						probOfDestruction *= 0.25;
					}

					return probOfDestruction;
			`

		}

	class Sensor {
		protected attribute fpr: `double`[1]
		protected attribute fnr: `double`[1]
		protected attribute uniform: `std::uniform_real_distribution`[1]
		protected attribute randomGenerator: `std::default_random_engine`[1]

		public operation Sensor(falsePositiveRate: `double`[1], falseNegativeRate: `double`[1]): `` `
			 fpr(falsePositiveRate);
			 fnr(falseNegativeRate);
			randomGenerator.seed(RandomSeed::getNextSeed());
		`
		public operation sense(truth: `bool`[1]): `bool` `
			bool result = truth;
			double random = uniform(randomGenerator);
			if (truth && random <= fnr) {
				result = false;
			} else if (!truth && random <= fpr) {
				result = true;
			}

			return result;
		`

	}
	class TargetSensor {
		protected attribute range: `double`[1]
		protected attribute detectionFormationFactor: `double`[1]
		protected attribute uniform: `std::uniform_real_distribution<>`[1]
		protected attribute randomGenerator: `std::default_random_engine`[1]

		public operation TargetSensor(range: `double`[1], detectionFormationFactor: `double`[1]): `` `
			  range(range);
			  detectionFormationFactor(detectionFormationFactor);
			  randomGenerator(RandomSeed::getNextSeed());
		`
		public operation sense(config: TeamConfiguration[1], targetPresent: `bool`[1]): `bool` `
			bool detected = false;
			if (targetPresent) {
				double probOfDetection = getProbabilityOfDetection(config);

				double random = uniform(randomGenerator);
				detected = (random <= probOfDetection);
			}
			return detected;
		`
		public operation getProbabilityOfDetection(config: TeamConfiguration[1]): `double` `
			double probOfDetection =
					((config.formation == TeamConfiguration::Formation::LOOSE) ? 1.0 : 1 / detectionFormationFactor)
					* max(0.0, range - config.altitudeLevel) / range;

			// ECM reduces the prob of detection
			if (config.ecm) {
				probOfDetection *= 0.25;
			}

			return probOfDetection;
		`


	}

	class DeterministicTargetSensor {
		protected attribute range: `double`[1]
		protected attribute detectionFormationFactor: `double`[1]
		protected attribute uniform: `std::uniform_real_distribution<>`[1]
		protected attribute randomGenerator: `std::default_random_engine`[1]

		public operation DeterministicTargetSensor(range: `double`[1], detectionFormationFactor: `double`[1]): `` `
			  range(range);
			  detectionFormationFactor(detectionFormationFactor);
			  randomGenerator(RandomSeed::getNextSeed());
		`
		public operation sense(config: TeamConfiguration[1], targetPresent: `bool`[1]): `bool` `
			bool detected = false;
			if (targetPresent) {
				double probOfDetection = getProbabilityOfDetection(config);

				double random = uniform(randomGenerator);
				detected = (random <= probOfDetection);
			}
			return detected;
		`
		public operation getProbabilityOfDetection(config: TeamConfiguration[1]): `double` `
			double effectiveRange = range;
			if (config.formation == TeamConfiguration::Formation::TIGHT) {
				effectiveRange = range / detectionFormationFactor;
			}

			// ECM reduces the range of detection
			if (config.ecm) {
				effectiveRange *= 0.75;
			}

			double probOfDetection = ((effectiveRange - config.altitudeLevel) > 0.0) ? 1.0 : 0.0;

			return probOfDetection;
		`


	}

    class Coordinate {
        public attribute x: int[1]
	    public attribute y: int[1]
    }
    class LongRangeSensorParams {
    	public attribute threatSensorFPR: `double`[1] = 0.10
    	public attribute threatSensorFNR: `double`[1] = 0.15
    	public attribute targetSensorFPR: `double`[1] = 0.10
    	public attribute targetSensorFNR: `double`[1] = 0.15
    }


		class DownwardLookingSensorParams {
			public attribute  targetDetectionFormationFactor: `double`[1] = 1.2
			public attribute  targetSensorRange: `unsigned`[1] = 4
		}

		class ThreatParams {
			public attribute  destructionFormationFactor: `double`[1] = 1.5
			public attribute  threatRange: `unsigned`[1] = 3 // in altitude levels
		}


		class SimulationParams {
			public attribute  mapSize: `unsigned`[1] = 40
			public attribute  squareMap: `bool`[1] = false
			public attribute  altitudeLevels: `unsigned`[1] = 4
			public attribute  changeAltitudeLatencyPeriods: `unsigned`[1] = 1
			public attribute  optimalityTest: `bool`[1] = false
			public attribute  longRangeSensor: `LongRangeSensorParams`[1]
			public attribute  downwardLookingSensor: `DownwardLookingSensorParams`[1]
			public attribute  threat: `ThreatParams`[1]
		}

		class SimulationResults {
			public attribute  destroyed: `bool`[1]
			public attribute  whereDestroyed: Coordinate[1]
			public attribute  targetsDetected: `unsigned`[1]
			public attribute  missionSuccess: `bool`[1]
			public attribute  decisionTimeAvg: `double`[1]
			public attribute  decisionTimeVar: `double`[1]
		}


		class TeamState {
			public attribute  position: Coordinate[1]
			public attribute  directionX: int[1]
			public attribute  directionY: int[1]
			public attribute  config: TeamConfiguration[1]
		}

		class Formation {
			public attribute LOOSE: int[1] = 0
			public attribute TIGHT: int[1] = 1

		}

		class TeamConfiguration {

			public attribute  altitudeLevel: `unsigned`[1]
			public attribute  formation: Formation[1]
			public attribute  ecm: `bool`[1]
			public attribute  ttcIncAlt: `unsigned`[1]
			public attribute  ttcDecAlt: `unsigned`[1]
			public attribute  ttcIncAlt2: `unsigned`[1]
			public attribute  ttcDecAlt2: `unsigned`[1]
		}
	

	protocol AdapterInterfaceToSimulatorProtocol {
		out message isFinished()
		out message readForwardThreatSensor(cells: `unsigned`[1])
		out message readForwardTargetSensor(cells: `unsigned`[1])
		out message readForwardThreatSensorForObservation(cells: `unsigned`[1], numOfObservations: `unsigned`[1])
		out message readForwardTargetSensorForObservation(cells: `unsigned`[1], numOfObservations: `unsigned`[1])
		out message step(tactics: TacticList[1], decisionTimeMsec: double[1]) // decisionTimeMsec defualts to 0
		out message getResults()
		out message getScreenOutput()
		out message getParameters()
		out message getState()
		out message createSimulator()


		in message sendIsFinished(finished: bool[1])
		in message sendReadForwardThreatSensor(readings: `std::vector<bool>`[1])
		in message sendReadForwardTargetSensor(readings: `std::vector<bool>`[1])
		in message sendReadForwardThreatSensorForObservation(readings: `std::vector<std::vector<bool>>`[1])
		in message sendReadForwardTargetSensorForObservation(readings: `std::vector<std::vector<bool>>`[1])
		in message sendStep(detection: bool[1]) 
		in message sendResults(simulationResults: SimulationResults[1])
		in message sendScreenOutput(screenOutput: string[1])
		in message sendParameters(simulationParams: SimulationParams[1])
		in message sendState(teamState: TeamState[1])
	}

	protocol SimulatorToForwardTargetSensor {
		out message createForwardTargetSensor(simulatorParams: SimulationParams[1])
		out message readForwardTargetSensor()

		in message sendReadForwardTargetSensor(sensedForwardTargetSensor: bool[1])

	}
	
	capsule AdapterInterface {
		port adapterManager: ~AdapterInterfaceToSimulatorProtocol
		port log: RTSLibrary.Log

		statemachine {
				initial initialStateAdapterInterfaceCapsule
				state running

				transition {
					from initialStateAdapterInterfaceCapsule
					to running
					action `
						log.log("[AdapterInterface] from initial state to running state");
					`
				}
		}	
		



	}

	capsule ForwardTargetSensor {
		port simulatorPort: ~SimulatorToForwardTargetSensor
		port log: RTSLibrary.Log

		statemachine {
			initial initialStateForwardTargetSensor
			state waitingStateForwardTargetSensor
			state runningForwardTargetSensor

				transition {
					from initialStateForwardTargetSensor
					to waitingStateForwardTargetSensor
					action `
						log.log("[ForwardTargetSensor] from initial state to waiting state");
					`
				}

				transition {
					from waitingStateForwardTargetSensor
					to runningForwardTargetSensor
					triggers from simulatorPort on createForwardTargetSensor
					action `
						log.log("[ForwardTargetSensor] from waiting state to running state");
					`
				}

		}
			


	}
	top capsule Top {
		part pinger : Pinger
		part ponger : Ponger
		connect ponger.pongPort to pinger.pingPort
	}
}
