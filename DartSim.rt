model DartSim {
	class RandomSeed {

	}
	class Sensor {

	}

    class Coordinate {
        public attribute x: int[1]
	    public attribute y: int[1]
    }
		class LongRangeSensorParams {
			public attribute threatSensorFPR: `double`[1] = 0.10
			public attribute threatSensorFNR: `double`[1] = 0.15
			public attribute targetSensorFPR: `double`[1] = 0.10
			public attribute targetSensorFNR: `double`[1] = 0.15
		}


		class DownwardLookingSensorParams {
			public attribute  targetDetectionFormationFactor: `double`[1] = 1.2
			public attribute  targetSensorRange: `unsigned`[1] = 4
		}

		class ThreatParams {
			public attribute  destructionFormationFactor: `double`[1] = 1.5
			public attribute  threatRange: `unsigned`[1] = 3 // in altitude levels
		}


		class SimulationParams {
			public attribute  mapSize: `unsigned`[1] = 40
			public attribute  squareMap: `bool`[1] = false
			public attribute  altitudeLevels: `unsigned`[1] = 4
			public attribute  changeAltitudeLatencyPeriods: `unsigned`[1] = 1
			public attribute  optimalityTest: `bool`[1] = false
			public attribute  longRangeSensor: `LongRangeSensorParams`[1]
			public attribute  downwardLookingSensor: `DownwardLookingSensorParams`[1]
			public attribute  threat: `ThreatParams`[1]
		}

		class SimulationResults {
			public attribute  destroyed: `bool`[1]
			public attribute  whereDestroyed: Coordinate[1]
			public attribute  targetsDetected: `unsigned`[1]
			public attribute  missionSuccess: `bool`[1]
			public attribute  decisionTimeAvg: `double`[1]
			public attribute  decisionTimeVar: `double`[1]
		}


		class TeamState {
			public attribute  position: Coordinate[1]
			public attribute  directionX: int[1]
			public attribute  directionY: int[1]
			public attribute  config: TeamConfiguration[1]
		}
	

	protocol AdapterInterfaceToSimulatorProtocol {
		out message isFinished()
		out message readForwardThreatSensor(cells: `unsigned`[1])
		out message readForwardTargetSensor(cells: `unsigned`[1])
		out message readForwardThreatSensorForObservation(cells: `unsigned`[1], numOfObservations: `unsigned`[1])
		out message readForwardTargetSensorForObservation(cells: `unsigned`[1], numOfObservations: `unsigned`[1])
		out message step(tactics: TacticList[1], decisionTimeMsec: double[1]) // decisionTimeMsec defualts to 0
		out message getResults()
		out message getScreenOutput()
		out message getParameters()
		out message getState()
		out message createSimulator()


		in message sendIsFinished(finished: bool[1])
		in message sendReadForwardThreatSensor(readings: `std::vector<bool>`[1])
		in message sendReadForwardTargetSensor(readings: `std::vector<bool>`[1])
		in message sendReadForwardThreatSensorForObservation(readings: `std::vector<std::vector<bool>>`[1])
		in message sendReadForwardTargetSensorForObservation(readings: `std::vector<std::vector<bool>>`[1])
		in message sendStep(detection: bool[1]) 
		in message sendResults(simulationResults: SimulationResults[1])
		in message sendScreenOutput(screenOutput: string[1])
		in message sendParameters(simulationParams: SimulationParams[1])
		in message sendState(teamState: TeamState[1])
	}

	protocol SimulatorToForwardTargetSensor {
		out message createForwardTargetSensor(simulatorParams: SimulationParams[1])
		out message readForwardTargetSensor()

		in message sendReadForwardTargetSensor(sensedForwardTargetSensor: bool[1])

	}
	
	capsule AdapterInterface {
		port adapterManager: ~AdapterInterfaceToSimulatorProtocol
		port log: RTSLibrary.Log

		statemachine {
				initial initialStateAdapterInterfaceCapsule
				state running

				transition {
					from initialStateAdapterInterfaceCapsule
					to running
					action `
						log.log("[AdapterInterface] from initial state to running state");
					`
				}
		}	
		



	}

	capsule ForwardTargetSensor {
		port simulatorPort: ~SimulatorToForwardTargetSensor
		port log: RTSLibrary.Log

		statemachine {
			initial initialStateForwardTargetSensor
			state waitingStateForwardTargetSensor
			state runningForwardTargetSensor

				transition {
					from initialStateForwardTargetSensor
					to waitingStateForwardTargetSensor
					action `
						log.log("[ForwardTargetSensor] from initial state to waiting state");
					`
				}

				transition {
					from waitingStateForwardTargetSensor
					to runningForwardTargetSensor
					triggers from simulatorPort on createForwardTargetSensor
					action `
						log.log("[ForwardTargetSensor] from waiting state to running state");
					`
				}

		}
			


	}
	capsule Pinger {
		port pingPort : ~PingPongProtocol
		port log: RTSLibrary.Log
		port timer: RTSLibrary.Timing

		statemachine {
			initial init
			state delay
			
			state playing {
				entry `
					if ( pingPort.ping().send() ) {
						log.log("ping sent!");
					} else {
						log.log("Error sending Ping!");
					}	
				`
			}
			
			transition {
				from init 
				to playing
				action `
					log.log("Starting game!");
				`
			}
			
			transition {
				from playing
				to delay
				triggers from pingPort on pong
				action `
					log.log("[Pinger] Pong received!");
					timer.informIn(UMLRTTimespec(1,0));
				`
			}

			transition {
				from delay
				to playing
				triggers from timer on timeout
			}		
		}
	}	
	
	capsule Ponger {
		port pongPort : PingPongProtocol
		port log: RTSLibrary.Log

		statemachine {
			initial init
			state playing
			
			transition { 
				from init 
				to playing
			}	
								
			transition {
				from playing
				to playing
				triggers from pongPort on ping
				action `
					log.log("[Ponger] Ping received!");
					if (pongPort.pong().send()){
						log.log("[Ponger] Pong sent!");
					} else {
						log.log("[Ponger] Error sending Pong!");
					}
				`
			}
		}
	}

	top capsule Top {
		part pinger : Pinger
		part ponger : Ponger
		connect ponger.pongPort to pinger.pingPort
	}
}
